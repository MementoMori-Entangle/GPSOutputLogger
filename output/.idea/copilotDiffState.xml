<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/../keystore.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../keystore.properties" />
              <option name="originalContent" value="storePassword=yourStorePassword&#10;keyPassword=yourKeyPassword&#10;keyAlias=yourKeyAlias&#10;storeFile=app/my-release-key.jks&#10;" />
              <option name="updatedContent" value="storePassword=yourStorePassword&#10;keyPassword=yourKeyPassword&#10;keyAlias=yourKeyAlias&#10;storeFile=app/my-release-key.jks&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import java.util.Properties&#10;import java.io.FileInputStream&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.entangle.gpsoutput&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.entangle.gpsoutput&quot;&#10;        minSdk = 33&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    signingConfigs {&#10;        create(&quot;release&quot;) {&#10;            val props = Properties()&#10;            props.load(FileInputStream(rootProject.file(&quot;keystore.properties&quot;)))&#10;            storeFile = file(props.getProperty(&quot;storeFile&quot;))&#10;            storePassword = props.getProperty(&quot;storePassword&quot;)&#10;            keyAlias = props.getProperty(&quot;keyAlias&quot;)&#10;            keyPassword = props.getProperty(&quot;keyPassword&quot;)&#10;&#10;            setProperty(&quot;archivesBaseName&quot;, &quot;GPSOutput-v${defaultConfig.versionName}&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;release&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.android.gms:play-services-location:21.0.1&quot;)&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
              <option name="updatedContent" value="import java.util.Properties&#10;import java.io.FileInputStream&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.entangle.gpsoutput&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.entangle.gpsoutput&quot;&#10;        minSdk = 33&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    signingConfigs {&#10;        create(&quot;release&quot;) {&#10;            val props = Properties()&#10;            props.load(FileInputStream(rootProject.file(&quot;output/keystore.properties&quot;)))&#10;            storeFile = file(props.getProperty(&quot;storeFile&quot;))&#10;            storePassword = props.getProperty(&quot;storePassword&quot;)&#10;            keyAlias = props.getProperty(&quot;keyAlias&quot;)&#10;            keyPassword = props.getProperty(&quot;keyPassword&quot;)&#10;&#10;            setProperty(&quot;archivesBaseName&quot;, &quot;GPSOutput-v${defaultConfig.versionName}&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            signingConfig = signingConfigs.getByName(&quot;release&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.androidx.navigation.fragment.ktx)&#10;    implementation(libs.androidx.navigation.ui.ktx)&#10;    implementation(&quot;com.google.android.gms:play-services-location:21.0.1&quot;)&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_BIOMETRIC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        android:theme=&quot;@style/Theme.GPSOutput&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.GPSOutput&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;service&#10;            android:name=&quot;.GpsService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;location&quot; /&gt;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_BIOMETRIC&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/gps_output&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/gps_output&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#13;&#10;        android:theme=&quot;@style/Theme.GPSOutput&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:theme=&quot;@style/Theme.GPSOutput&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;        &lt;service&#13;&#10;            android:name=&quot;.GpsService&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:foregroundServiceType=&quot;location&quot; /&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/AppConstants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/AppConstants.kt" />
              <option name="updatedContent" value="package com.entangle.gpsoutput&#10;&#10;object AppConstants {&#10;    const val DEFAULT_IP = &quot;192.168.11.7&quot;&#10;    const val DEFAULT_PORT = 50052&#10;    const val DEFAULT_TIMEOUT = 5000L&#10;    const val DEFAULT_SEND_TYPE = &quot;http&quot;&#10;    const val DEFAULT_SCHEME = &quot;http&quot;&#10;    const val DEFAULT_MIN_INTERVAL = 1&#10;    const val DEFAULT_MAX_INTERVAL = 60&#10;    const val DEFAULT_INTERVAL = 1&#10;    const val DEFAULT_INTERVAL_MILLIS = 1000L&#10;    const val MAX_ERROR_COUNT = 5&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/BleManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/BleManager.kt" />
              <option name="originalContent" value="package com.entangle.gpsoutput&#10;&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothGattService&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothProfile&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import androidx.core.content.ContextCompat&#10;import java.util.UUID&#10;&#10;class BleManager(private val context: Context) {&#10;    private var bluetoothGatt: BluetoothGatt? = null&#10;    private var characteristic: BluetoothGattCharacteristic? = null&#10;    private var isConnected = false&#10;&#10;    // サンプルUUID（実際のサービス/キャラUUIDに合わせて修正してください）&#10;    companion object {&#10;        val SERVICE_UUID: UUID = UUID.fromString(&quot;0000180A-0000-1000-8000-00805f9b34fb&quot;)&#10;        val CHARACTERISTIC_UUID: UUID = UUID.fromString(&quot;00002A57-0000-1000-8000-00805f9b34fb&quot;)&#10;    }&#10;&#10;    // IP・ポート保存用&#10;    private val PREF_NAME = &quot;connection_info&quot;&#10;    private val KEY_IP = &quot;ip_address&quot;&#10;    private val KEY_PORT = &quot;port&quot;&#10;&#10;    @android.annotation.SuppressLint(&quot;MissingPermission&quot;)&#10;    fun connect(device: BluetoothDevice, onConnected: () -&gt; Unit, onDisconnected: () -&gt; Unit) {&#10;        // BLUETOOTH_CONNECTパーミッションが必要&#10;        val hasPermission = ContextCompat.checkSelfPermission(context, android.Manifest.permission.BLUETOOTH_CONNECT) == PackageManager.PERMISSION_GRANTED&#10;        if (!hasPermission) {&#10;            onDisconnected()&#10;            return&#10;        }&#10;        try {&#10;            bluetoothGatt = device.connectGatt(context, false, object : BluetoothGattCallback() {&#10;                override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {&#10;                    if (newState == BluetoothProfile.STATE_CONNECTED) {&#10;                        isConnected = true&#10;                        gatt.discoverServices()&#10;                    } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                        isConnected = false&#10;                        onDisconnected()&#10;                    }&#10;                }&#10;                override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;                    val service: BluetoothGattService? = gatt.getService(SERVICE_UUID)&#10;                    characteristic = service?.getCharacteristic(CHARACTERISTIC_UUID)&#10;                    if (characteristic != null) {&#10;                        onConnected()&#10;                    } else {&#10;                        onDisconnected()&#10;                    }&#10;                }&#10;            })&#10;        } catch (e: SecurityException) {&#10;            onDisconnected()&#10;        }&#10;    }&#10;&#10;    @android.annotation.SuppressLint(&quot;MissingPermission&quot;)&#10;    fun send(data: ByteArray) {&#10;        // BLUETOOTH_CONNECTパーミッションが必要&#10;        val hasPermission = ContextCompat.checkSelfPermission(context, android.Manifest.permission.BLUETOOTH_CONNECT) == PackageManager.PERMISSION_GRANTED&#10;        if (!hasPermission) {&#10;            return&#10;        }&#10;        try {&#10;            if (isConnected &amp;&amp; characteristic != null &amp;&amp; bluetoothGatt != null) {&#10;                characteristic?.value = data&#10;                bluetoothGatt?.writeCharacteristic(characteristic)&#10;            }&#10;        } catch (e: SecurityException) {&#10;            // パーミッションエラー時は何もしない&#10;        }&#10;    }&#10;&#10;    @android.annotation.SuppressLint(&quot;MissingPermission&quot;)&#10;    fun disconnect() {&#10;        bluetoothGatt?.disconnect()&#10;        bluetoothGatt?.close()&#10;        bluetoothGatt = null&#10;        characteristic = null&#10;        isConnected = false&#10;    }&#10;&#10;    fun saveConnectionInfo(ip: String, port: Int) {&#10;        val prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)&#10;        prefs.edit().putString(KEY_IP, ip).putInt(KEY_PORT, port).apply()&#10;    }&#10;&#10;    fun getConnectionInfo(): Pair&lt;String?, Int?&gt; {&#10;        val prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)&#10;        val ip = prefs.getString(KEY_IP, null)&#10;        val port = if (prefs.contains(KEY_PORT)) prefs.getInt(KEY_PORT, -1) else null&#10;        return Pair(ip, port)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.entangle.gpsoutput&#10;&#10;import android.content.Context&#10;&#10;class BleManager(private val context: Context) {&#10;    // このファイルはBLE/SPP関連の処理を全て削除します&#10;    // BLE/SPP関連のクラス・メソッド・フィールドを削除&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/GpsService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/GpsService.kt" />
              <option name="originalContent" value="package com.entangle.gpsoutput&#10;&#10;import android.Manifest&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationCompat&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;&#10;class GpsService : Service() {&#10;    companion object {&#10;        const val DEFAULT_IP = &quot;192.168.11.7&quot;&#10;        const val DEFAULT_PORT = 50052&#10;        const val DEFAULT_SCHEME = &quot;http&quot;&#10;        const val DEFAULT_SEND_TYPE = &quot;http&quot;&#10;        const val DEFAULT_INTERVAL_MILLIS = 1000L&#10;        const val MAX_ERROR_COUNT = 5&#10;    }&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var locationCallback: LocationCallback&#10;    private var intervalMillis: Long = DEFAULT_INTERVAL_MILLIS&#10;    private var sendType: String = DEFAULT_SEND_TYPE // &quot;http&quot;, &quot;tcp&quot;, &quot;udp&quot;&#10;    private var serverAddress: String = DEFAULT_IP // IP&#10;    private var serverPort: Int = DEFAULT_PORT // HTTP: 5000, TCP/UDP: 任意&#10;    private var gpsReady: Boolean = false&#10;    private var scheme: String = DEFAULT_SCHEME // スキーム保持&#10;    private var errorCount: Int = 0&#10;    private val maxErrorCount: Int = MAX_ERROR_COUNT // デフォルト最大回数&#10;    private var tcpSocket: java.net.Socket? = null&#10;    private var tcpWriter: java.io.OutputStream? = null&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onCreate() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onCreate called&quot;)&#10;        super.onCreate()&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onStartCommand called&quot;)&#10;        try {&#10;            intervalMillis = intent?.getLongExtra(&quot;intervalMillis&quot;, DEFAULT_INTERVAL_MILLIS) ?: DEFAULT_INTERVAL_MILLIS&#10;            sendType = intent?.getStringExtra(&quot;sendType&quot;) ?: DEFAULT_SEND_TYPE&#10;            serverAddress = intent?.getStringExtra(&quot;serverAddress&quot;) ?: DEFAULT_IP&#10;            serverPort = intent?.getIntExtra(&quot;serverPort&quot;, DEFAULT_PORT) ?: DEFAULT_PORT&#10;            scheme = intent?.getStringExtra(&quot;scheme&quot;) ?: DEFAULT_SCHEME // スキーム取得&#10;            startForegroundService()&#10;            startLocationUpdates()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GpsService&quot;, &quot;Exception in onStartCommand: ${e.message}&quot;, e)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;startForegroundService called&quot;)&#10;        val channelId = &quot;gps_service_channel&quot;&#10;        val channel = NotificationChannel(channelId, &quot;GPS Service&quot;, NotificationManager.IMPORTANCE_LOW)&#10;        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        manager.createNotificationChannel(channel)&#10;        val notification: Notification = NotificationCompat.Builder(this, channelId)&#10;            .setContentTitle(&quot;GPS送信中&quot;)&#10;            .setContentText(&quot;位置情報を送信しています&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_menu_mylocation)&#10;            .build()&#10;        startForeground(1, notification)&#10;    }&#10;&#10;    private fun sendGpsOverHttp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                val url = java.net.URL(&quot;$scheme://$serverAddress:$serverPort/gps&quot;)&#10;                val conn = url.openConnection() as java.net.HttpURLConnection&#10;                conn.requestMethod = &quot;POST&quot;&#10;                conn.doOutput = true&#10;                conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                val json = &quot;{\&quot;lat\&quot;:$latitude,\&quot;lon\&quot;:$longitude,\&quot;time\&quot;:$timestamp}&quot;&#10;                conn.outputStream.use { it.write(json.toByteArray()) }&#10;                conn.inputStream.close()&#10;                errorCount = 0 // 成功時はリセット&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;HTTP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;HTTP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendGpsOverTcp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                if (tcpSocket == null || tcpSocket!!.isClosed) {&#10;                    tcpSocket = java.net.Socket(serverAddress, serverPort)&#10;                    tcpWriter = tcpSocket!!.getOutputStream()&#10;                }&#10;                val data = &quot;$latitude,$longitude,$timestamp\n&quot;&#10;                tcpWriter?.write(data.toByteArray())&#10;                tcpWriter?.flush()&#10;                errorCount = 0&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;TCP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;TCP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendGpsOverUdp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                val socket = java.net.DatagramSocket()&#10;                val data = &quot;$latitude,$longitude,$timestamp&quot;&#10;                val packet = java.net.DatagramPacket(data.toByteArray(), data.length, java.net.InetAddress.getByName(serverAddress), serverPort)&#10;                socket.send(packet)&#10;                socket.close()&#10;                errorCount = 0&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;UDP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;UDP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendErrorBroadcast(message: String) {&#10;        val intent = Intent(&quot;com.entangle.gpsOutput.ERROR&quot;)&#10;        intent.putExtra(&quot;error_message&quot;, message)&#10;        sendBroadcast(intent)&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;startLocationUpdates called&quot;)&#10;        gpsReady = false&#10;        val request = LocationRequest.Builder(intervalMillis)&#10;            .setIntervalMillis(intervalMillis)&#10;            .setMinUpdateIntervalMillis(intervalMillis)&#10;            .setPriority(Priority.PRIORITY_HIGH_ACCURACY)&#10;            .build()&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;LocationCallback before&quot;)&#10;        locationCallback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                android.util.Log.d(&quot;GpsService&quot;, &quot;onLocationResult called&quot;)&#10;                var sentDummy = false&#10;                for (location in result.locations) {&#10;                    if (!gpsReady &amp;&amp; location.accuracy &lt; 50) {&#10;                        gpsReady = true&#10;                        android.util.Log.d(&quot;GpsService&quot;, &quot;GPS ready: ${location.latitude},${location.longitude}&quot;)&#10;                    }&#10;                    val lat = location.latitude&#10;                    val lon = location.longitude&#10;                    val time = location.time&#10;                    // MainActivityへ位置情報をBroadcast&#10;                    val locIntent = Intent(&quot;com.entangle.gpsOutput.LOCATION&quot;)&#10;                    locIntent.putExtra(&quot;latitude&quot;, lat)&#10;                    locIntent.putExtra(&quot;longitude&quot;, lon)&#10;                    sendBroadcast(locIntent)&#10;                    if (gpsReady) {&#10;                        when (sendType) {&#10;                            &quot;http&quot; -&gt; sendGpsOverHttp(lat, lon, time)&#10;                            &quot;tcp&quot; -&gt; sendGpsOverTcp(lat, lon, time)&#10;                            &quot;udp&quot; -&gt; sendGpsOverUdp(lat, lon, time)&#10;                        }&#10;                    } else if (!sentDummy) {&#10;                        // GPS未取得時はダミーデータ送信&#10;                        when (sendType) {&#10;                            &quot;http&quot; -&gt; sendGpsOverHttp(0.0, 0.0, 0)&#10;                            &quot;tcp&quot; -&gt; sendGpsOverTcp(0.0, 0.0, 0)&#10;                            &quot;udp&quot; -&gt; sendGpsOverUdp(0.0, 0.0, 0)&#10;                        }&#10;                        sentDummy = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            android.util.Log.d(&quot;GpsService&quot;, &quot;ACCESS_FINE_LOCATION not granted, stopping service&quot;)&#10;            stopSelf()&#10;            return&#10;        }&#10;        fusedLocationClient.requestLocationUpdates(request, locationCallback, Looper.getMainLooper())&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onDestroy called&quot;)&#10;        super.onDestroy()&#10;        if (::fusedLocationClient.isInitialized &amp;&amp; ::locationCallback.isInitialized) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        }&#10;        // TCP接続をクリーンアップ&#10;        try {&#10;            tcpWriter?.close()&#10;            tcpSocket?.close()&#10;        } catch (_: Exception) {}&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.entangle.gpsoutput&#10;&#10;import android.Manifest&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.app.NotificationCompat&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.Priority&#10;&#10;class GpsService : Service() {&#10;    private lateinit var fusedLocationClient: FusedLocationProviderClient&#10;    private lateinit var locationCallback: LocationCallback&#10;    private var intervalMillis: Long = AppConstants.DEFAULT_INTERVAL_MILLIS&#10;    private var sendType: String = AppConstants.DEFAULT_SEND_TYPE // &quot;http&quot;, &quot;tcp&quot;, &quot;udp&quot;&#10;    private var serverAddress: String = AppConstants.DEFAULT_IP // IP&#10;    private var serverPort: Int = AppConstants.DEFAULT_PORT // HTTP: 5000, TCP/UDP: 任意&#10;    private var gpsReady: Boolean = false&#10;    private var scheme: String = AppConstants.DEFAULT_SCHEME // スキーム保持&#10;    private var errorCount: Int = 0&#10;    private val maxErrorCount: Int = AppConstants.MAX_ERROR_COUNT // デフォルト最大回数&#10;    private var tcpSocket: java.net.Socket? = null&#10;    private var tcpWriter: java.io.OutputStream? = null&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onCreate() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onCreate called&quot;)&#10;        super.onCreate()&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onStartCommand called&quot;)&#10;        try {&#10;            intervalMillis = intent?.getLongExtra(&quot;intervalMillis&quot;, AppConstants.DEFAULT_INTERVAL_MILLIS) ?: AppConstants.DEFAULT_INTERVAL_MILLIS&#10;            sendType = intent?.getStringExtra(&quot;sendType&quot;) ?: AppConstants.DEFAULT_SEND_TYPE&#10;            serverAddress = intent?.getStringExtra(&quot;serverAddress&quot;) ?: AppConstants.DEFAULT_IP&#10;            serverPort = intent?.getIntExtra(&quot;serverPort&quot;, AppConstants.DEFAULT_PORT) ?: AppConstants.DEFAULT_PORT&#10;            scheme = intent?.getStringExtra(&quot;scheme&quot;) ?: AppConstants.DEFAULT_SCHEME // スキーム取得&#10;            startForegroundService()&#10;            startLocationUpdates()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;GpsService&quot;, &quot;Exception in onStartCommand: ${e.message}&quot;, e)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;startForegroundService called&quot;)&#10;        val channelId = &quot;gps_service_channel&quot;&#10;        val channel = NotificationChannel(channelId, &quot;GPS Service&quot;, NotificationManager.IMPORTANCE_LOW)&#10;        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        manager.createNotificationChannel(channel)&#10;        val notification: Notification = NotificationCompat.Builder(this, channelId)&#10;            .setContentTitle(&quot;GPS送信中&quot;)&#10;            .setContentText(&quot;位置情報を送信しています&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_menu_mylocation)&#10;            .build()&#10;        startForeground(1, notification)&#10;    }&#10;&#10;    private fun sendGpsOverHttp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                val url = java.net.URL(&quot;$scheme://$serverAddress:$serverPort/gps&quot;)&#10;                val conn = url.openConnection() as java.net.HttpURLConnection&#10;                conn.requestMethod = &quot;POST&quot;&#10;                conn.doOutput = true&#10;                conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                val json = &quot;{\&quot;lat\&quot;:$latitude,\&quot;lon\&quot;:$longitude,\&quot;time\&quot;:$timestamp}&quot;&#10;                conn.outputStream.use { it.write(json.toByteArray()) }&#10;                conn.inputStream.close()&#10;                errorCount = 0 // 成功時はリセット&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;HTTP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;HTTP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendGpsOverTcp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                if (tcpSocket == null || tcpSocket!!.isClosed) {&#10;                    tcpSocket = java.net.Socket(serverAddress, serverPort)&#10;                    tcpWriter = tcpSocket!!.getOutputStream()&#10;                }&#10;                val data = &quot;$latitude,$longitude,$timestamp\n&quot;&#10;                tcpWriter?.write(data.toByteArray())&#10;                tcpWriter?.flush()&#10;                errorCount = 0&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;TCP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;TCP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendGpsOverUdp(latitude: Double, longitude: Double, timestamp: Long) {&#10;        Thread {&#10;            try {&#10;                val socket = java.net.DatagramSocket()&#10;                val data = &quot;$latitude,$longitude,$timestamp&quot;&#10;                val packet = java.net.DatagramPacket(data.toByteArray(), data.length, java.net.InetAddress.getByName(serverAddress), serverPort)&#10;                socket.send(packet)&#10;                socket.close()&#10;                errorCount = 0&#10;            } catch (e: Exception) {&#10;                errorCount++&#10;                android.util.Log.e(&quot;GpsService&quot;, &quot;UDP送信エラー: ${e.message}&quot;)&#10;                sendErrorBroadcast(e.message ?: &quot;UDP送信エラー&quot;)&#10;                if (errorCount &gt;= maxErrorCount) {&#10;                    sendErrorBroadcast(&quot;送信失敗が${maxErrorCount}回連続したため送信を停止します&quot;)&#10;                    stopSelf()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun sendErrorBroadcast(message: String) {&#10;        val intent = Intent(&quot;com.entangle.gpsOutput.ERROR&quot;)&#10;        intent.putExtra(&quot;error_message&quot;, message)&#10;        sendBroadcast(intent)&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;startLocationUpdates called&quot;)&#10;        gpsReady = false&#10;        val request = LocationRequest.Builder(intervalMillis)&#10;            .setIntervalMillis(intervalMillis)&#10;            .setMinUpdateIntervalMillis(intervalMillis)&#10;            .setPriority(Priority.PRIORITY_HIGH_ACCURACY)&#10;            .build()&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;LocationCallback before&quot;)&#10;        locationCallback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                android.util.Log.d(&quot;GpsService&quot;, &quot;onLocationResult called&quot;)&#10;                var sentDummy = false&#10;                for (location in result.locations) {&#10;                    if (!gpsReady &amp;&amp; location.accuracy &lt; 50) {&#10;                        gpsReady = true&#10;                        android.util.Log.d(&quot;GpsService&quot;, &quot;GPS ready: ${location.latitude},${location.longitude}&quot;)&#10;                    }&#10;                    val lat = location.latitude&#10;                    val lon = location.longitude&#10;                    val time = location.time&#10;                    // MainActivityへ位置情報をBroadcast&#10;                    val locIntent = Intent(&quot;com.entangle.gpsOutput.LOCATION&quot;)&#10;                    locIntent.putExtra(&quot;latitude&quot;, lat)&#10;                    locIntent.putExtra(&quot;longitude&quot;, lon)&#10;                    sendBroadcast(locIntent)&#10;                    if (gpsReady) {&#10;                        when (sendType) {&#10;                            &quot;http&quot; -&gt; sendGpsOverHttp(lat, lon, time)&#10;                            &quot;tcp&quot; -&gt; sendGpsOverTcp(lat, lon, time)&#10;                            &quot;udp&quot; -&gt; sendGpsOverUdp(lat, lon, time)&#10;                        }&#10;                    } else if (!sentDummy) {&#10;                        // GPS未取得時はダミーデータ送信&#10;                        when (sendType) {&#10;                            &quot;http&quot; -&gt; sendGpsOverHttp(0.0, 0.0, 0)&#10;                            &quot;tcp&quot; -&gt; sendGpsOverTcp(0.0, 0.0, 0)&#10;                            &quot;udp&quot; -&gt; sendGpsOverUdp(0.0, 0.0, 0)&#10;                        }&#10;                        sentDummy = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {&#10;            android.util.Log.d(&quot;GpsService&quot;, &quot;ACCESS_FINE_LOCATION not granted, stopping service&quot;)&#10;            stopSelf()&#10;            return&#10;        }&#10;        fusedLocationClient.requestLocationUpdates(request, locationCallback, Looper.getMainLooper())&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        android.util.Log.d(&quot;GpsService&quot;, &quot;onDestroy called&quot;)&#10;        super.onDestroy()&#10;        if (::fusedLocationClient.isInitialized &amp;&amp; ::locationCallback.isInitialized) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback)&#10;        }&#10;        // TCP接続をクリーンアップ&#10;        try {&#10;            tcpWriter?.close()&#10;            tcpSocket?.close()&#10;        } catch (_: Exception) {}&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/MainActivity.kt" />
              <option name="originalContent" value="package com.entangle.gpsoutput&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.MenuItem&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.SeekBar&#10;import android.widget.Spinner&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.edit&#10;import com.entangle.gpsoutput.databinding.ActivityMainBinding&#10;import android.widget.LinearLayout&#10;import org.json.JSONObject&#10;import java.io.InputStream&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var binding: ActivityMainBinding&#10;    private var isSending = false&#10;&#10;    private lateinit var gpsStatusText: TextView&#10;    private lateinit var gpsLatLngText: TextView&#10;    private var currentLocation: Location? = null&#10;&#10;    private val prefsName = &quot;gps_output_settings&quot;&#10;    private val keyIp = &quot;ip&quot;&#10;    private val keyPort = &quot;port&quot;&#10;    private val keyTimeout = &quot;timeout&quot;&#10;    private val keySendType = &quot;sendType&quot;&#10;&#10;    private lateinit var errorReceiver: android.content.BroadcastReceiver&#10;    private lateinit var locationReceiver: android.content.BroadcastReceiver&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onCreate called&quot;)&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;        setSupportActionBar(binding.toolbar)&#10;&#10;        // GPS情報表示用TextViewを動的に追加&#10;        gpsStatusText = TextView(this).apply {&#10;            text = &quot;&quot;&#10;            textSize = 16f&#10;        }&#10;        gpsLatLngText = TextView(this).apply {&#10;            text = &quot;&quot;&#10;            textSize = 16f&#10;        }&#10;        // rootLayoutを画面の一番下に追加&#10;        val rootLayout = findViewById&lt;LinearLayout&gt;(R.id.root_layout)&#10;        rootLayout.addView(gpsStatusText)&#10;        rootLayout.addView(gpsLatLngText)&#10;&#10;        checkAndRequestPermissions()&#10;&#10;        // Wi-Fi送信設定UI&#10;        val ipEditText = findViewById&lt;EditText&gt;(R.id.ip_edittext)&#10;        val portEditText = findViewById&lt;EditText&gt;(R.id.port_edittext)&#10;        val timeoutEditText = findViewById&lt;EditText&gt;(R.id.timeout_edittext)&#10;        val sendTypeSpinner = findViewById&lt;Spinner&gt;(R.id.send_type_spinner)&#10;        val sendTypeAdapter = android.widget.ArrayAdapter(&#10;            this,&#10;            android.R.layout.simple_spinner_item,&#10;            listOf(&quot;http&quot;, &quot;https&quot;, &quot;tcp&quot;, &quot;udp&quot;)&#10;        )&#10;        sendTypeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)&#10;        sendTypeSpinner.adapter = sendTypeAdapter&#10;        sendTypeSpinner.setSelection(0)&#10;&#10;        // 設定値の読み込み（保存値があればそちらを優先）&#10;        val prefs = getSharedPreferences(prefsName, Context.MODE_PRIVATE)&#10;        // config.jsonの値を初回のみSharedPreferencesへ保存&#10;        if (!prefs.contains(keyIp) || !prefs.contains(keyPort) || !prefs.contains(keyTimeout) || !prefs.contains(keySendType)) {&#10;            val config = readConfigJson()&#10;            if (config != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;Config loaded: $config&quot;)&#10;                prefs.edit(true) {&#10;                    putString(keyIp, config.optString(&quot;ip&quot;, AppConstants.DEFAULT_IP))&#10;                    putInt(keyPort, config.optInt(&quot;port&quot;, AppConstants.DEFAULT_PORT))&#10;                    putLong(keyTimeout, config.optLong(&quot;timeout&quot;, AppConstants.DEFAULT_TIMEOUT))&#10;                    putString(keySendType, config.optString(&quot;sendType&quot;, AppConstants.DEFAULT_SEND_TYPE))&#10;                }&#10;            }&#10;        }&#10;        // SharedPreferencesから値を取得してUIに反映&#10;        ipEditText.setText(prefs.getString(keyIp, AppConstants.DEFAULT_IP))&#10;        portEditText.setText(prefs.getInt(keyPort, AppConstants.DEFAULT_PORT).toString())&#10;        timeoutEditText.setText(prefs.getLong(keyTimeout, AppConstants.DEFAULT_TIMEOUT).toString())&#10;        val prefsSendType = prefs.getString(keySendType, AppConstants.DEFAULT_SEND_TYPE)&#10;        sendTypeSpinner.setSelection(listOf(&quot;http&quot;, &quot;https&quot;, &quot;tcp&quot;, &quot;udp&quot;).indexOf(prefsSendType))&#10;&#10;        val startButton = findViewById&lt;Button&gt;(R.id.start_button)&#10;        val stopButton = findViewById&lt;Button&gt;(R.id.stop_button)&#10;        startButton.isEnabled = true&#10;        stopButton.isEnabled = false&#10;&#10;        // 設定ファイルからスライダーの値を取得&#10;        val minInterval = prefs.getInt(&quot;minInterval&quot;, AppConstants.DEFAULT_MIN_INTERVAL)&#10;        val maxInterval = prefs.getInt(&quot;maxInterval&quot;, AppConstants.DEFAULT_MAX_INTERVAL)&#10;        val defaultInterval = prefs.getInt(&quot;defaultInterval&quot;, AppConstants.DEFAULT_INTERVAL)&#10;        val intervalSeekBar = findViewById&lt;SeekBar&gt;(R.id.interval_seekbar)&#10;        intervalSeekBar.min = minInterval&#10;        intervalSeekBar.max = maxInterval&#10;        intervalSeekBar.progress = defaultInterval&#10;&#10;        val intervalValueView = findViewById&lt;TextView&gt;(R.id.interval_value)&#10;        intervalValueView.text = getString(R.string.send_interval, defaultInterval)&#10;&#10;        intervalSeekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                intervalValueView.text = getString(R.string.send_interval, progress)&#10;            }&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {}&#10;        })&#10;&#10;        startButton.setOnClickListener {&#10;            val ip = ipEditText.text.toString().ifEmpty { AppConstants.DEFAULT_IP }&#10;            val port = portEditText.text.toString().toIntOrNull() ?: AppConstants.DEFAULT_PORT&#10;            val timeout = timeoutEditText.text.toString().toLongOrNull() ?: AppConstants.DEFAULT_TIMEOUT&#10;            val sendType = sendTypeSpinner.selectedItem.toString()&#10;            var scheme = AppConstants.DEFAULT_SCHEME&#10;            var type = sendType&#10;            val interval = intervalSeekBar.progress.toLong()&#10;            if (sendType == &quot;http&quot; || sendType == &quot;https&quot;) {&#10;                scheme = sendType&#10;                type = &quot;http&quot;&#10;            }&#10;            val intent = Intent(this, GpsService::class.java)&#10;            intent.putExtra(&quot;serverAddress&quot;, ip)&#10;            intent.putExtra(&quot;serverPort&quot;, port)&#10;            intent.putExtra(&quot;sendType&quot;, type)&#10;            intent.putExtra(&quot;intervalMillis&quot;, interval * 1000)&#10;            intent.putExtra(&quot;timeoutMillis&quot;, timeout)&#10;            intent.putExtra(&quot;scheme&quot;, scheme)&#10;            // 設定値の保存（即時反映）&#10;            prefs.edit(true) {&#10;                putString(keyIp, ip)&#10;                putInt(keyPort, port)&#10;                putLong(keyTimeout, timeout)&#10;                putString(keySendType, sendType)&#10;            }&#10;            startForegroundService(intent)&#10;            Toast.makeText(this, &quot;GPS送信サービス開始&quot;, Toast.LENGTH_SHORT).show()&#10;            isSending = true&#10;            setSendingStatus(true)&#10;            startButton.isEnabled = false&#10;            stopButton.isEnabled = true&#10;        }&#10;        stopButton.setOnClickListener {&#10;            stopService(Intent(this, GpsService::class.java))&#10;            Toast.makeText(this, &quot;GPS送信サービス停止&quot;, Toast.LENGTH_SHORT).show()&#10;            isSending = false&#10;            setSendingStatus(false)&#10;            startButton.isEnabled = true&#10;            stopButton.isEnabled = false&#10;        }&#10;&#10;        errorReceiver = object : android.content.BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                if (intent?.action == &quot;com.entangle.gpsOutput.ERROR&quot;) {&#10;                    val errorMsg = intent.getStringExtra(&quot;error_message&quot;) ?: getString(R.string.send_error)&#10;                    setSendingStatus(false)&#10;                    findViewById&lt;Button&gt;(R.id.start_button).isEnabled = true&#10;                    Toast.makeText(this@MainActivity, getString(R.string.send_error_message, errorMsg), Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;        val filter = android.content.IntentFilter(&quot;com.entangle.gpsOutput.ERROR&quot;)&#10;        registerReceiver(errorReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;&#10;        // 位置情報受信用BroadcastReceiverの登録&#10;        locationReceiver = object : android.content.BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                if (intent?.action == &quot;com.entangle.gpsOutput.LOCATION&quot;) {&#10;                    val lat = intent.getDoubleExtra(&quot;latitude&quot;, 0.0)&#10;                    val lng = intent.getDoubleExtra(&quot;longitude&quot;, 0.0)&#10;                    gpsStatusText.text = getString(R.string.gps_acquired)&#10;                    gpsLatLngText.text = getString(R.string.lat_lng, lat, lng)&#10;                    currentLocation = Location(&quot;service&quot;).apply {&#10;                        latitude = lat&#10;                        longitude = lng&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        val locFilter = android.content.IntentFilter(&quot;com.entangle.gpsOutput.LOCATION&quot;)&#10;        registerReceiver(locationReceiver, locFilter, Context.RECEIVER_NOT_EXPORTED)&#10;&#10;        // テキストボックス変更時に即保存&#10;        ipEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val ip = ipEditText.text.toString().ifEmpty { AppConstants.DEFAULT_IP }&#10;                prefs.edit(true) { putString(keyIp, ip) }&#10;            }&#10;        }&#10;        portEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val port = portEditText.text.toString().toIntOrNull() ?: AppConstants.DEFAULT_PORT&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;Port changed: $port&quot;)&#10;                prefs.edit(true) { putInt(keyPort, port) }&#10;            }&#10;        }&#10;        timeoutEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val timeout = timeoutEditText.text.toString().toLongOrNull() ?: AppConstants.DEFAULT_TIMEOUT&#10;                prefs.edit(true) { putLong(keyTimeout, timeout) }&#10;            }&#10;        }&#10;        sendTypeSpinner.setOnItemSelectedListener(object : android.widget.AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: android.widget.AdapterView&lt;*&gt;, view: android.view.View?, position: Int, id: Long) {&#10;                val sendType = parent.getItemAtPosition(position).toString()&#10;                prefs.edit(true) { putString(keySendType, sendType) }&#10;            }&#10;            override fun onNothingSelected(parent: android.widget.AdapterView&lt;*&gt;) {}&#10;        })&#10;    }&#10;&#10;    // 権限リクエストの結果を受け取る&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;    }&#10;&#10;    private fun checkAndRequestPermissions() {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;checkAndRequestPermissions called&quot;)&#10;        val permissionsToRequest = mutableListOf&lt;String&gt;()&#10;        permissionsToRequest.add(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        permissionsToRequest.add(Manifest.permission.ACCESS_COARSE_LOCATION)&#10;&#10;        val permissionsNotGranted = permissionsToRequest.filter {&#10;            ActivityCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNotGranted.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNotGranted.toTypedArray(), 100)&#10;        }&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu): Boolean {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onCreateOptionsMenu called&quot;)&#10;        menuInflater.inflate(R.menu.menu_main, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onOptionsItemSelected called&quot;)&#10;        return when (item.itemId) {&#10;            R.id.action_background -&gt; {&#10;                moveTaskToBack(true)&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun setSendingStatus(isSending: Boolean) {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;setSendingStatus called: isSending=$isSending&quot;)&#10;        gpsStatusText.text = if (isSending) &quot;送信中&quot; else &quot;&quot;&#10;        if (isSending &amp;&amp; currentLocation != null) {&#10;            gpsLatLngText.text = getString(R.string.lat_lng, currentLocation!!.latitude, currentLocation!!.longitude)&#10;        } else if (!isSending) {&#10;            gpsLatLngText.text = getString(R.string.lat_lng_not_acquired)&#10;        }&#10;    }&#10;&#10;    private fun readConfigJson(): JSONObject? {&#10;        return try {&#10;            val inputStream: InputStream = assets.open(&quot;config.json&quot;)&#10;            val size = inputStream.available()&#10;            val buffer = ByteArray(size)&#10;            inputStream.read(buffer)&#10;            inputStream.close()&#10;            val json = String(buffer, Charsets.UTF_8)&#10;            JSONObject(json)&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(errorReceiver)&#10;        unregisterReceiver(locationReceiver)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.entangle.gpsoutput&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.MenuItem&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.SeekBar&#10;import android.widget.Spinner&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.edit&#10;import com.entangle.gpsoutput.databinding.ActivityMainBinding&#10;import android.widget.LinearLayout&#10;import org.json.JSONObject&#10;import java.io.InputStream&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var binding: ActivityMainBinding&#10;    private var isSending = false&#10;&#10;    private lateinit var gpsStatusText: TextView&#10;    private lateinit var gpsLatLngText: TextView&#10;    private var currentLocation: Location? = null&#10;&#10;    private val prefsName = &quot;gps_output_settings&quot;&#10;    private val keyIp = &quot;ip&quot;&#10;    private val keyPort = &quot;port&quot;&#10;    private val keyTimeout = &quot;timeout&quot;&#10;    private val keySendType = &quot;sendType&quot;&#10;&#10;    private lateinit var errorReceiver: android.content.BroadcastReceiver&#10;    private lateinit var locationReceiver: android.content.BroadcastReceiver&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onCreate called&quot;)&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;        setSupportActionBar(binding.toolbar)&#10;&#10;        // GPS情報表示用TextViewを動的に追加&#10;        gpsStatusText = TextView(this).apply {&#10;            text = &quot;&quot;&#10;            textSize = 16f&#10;        }&#10;        gpsLatLngText = TextView(this).apply {&#10;            text = &quot;&quot;&#10;            textSize = 16f&#10;        }&#10;        // rootLayoutを画面の一番下に追加&#10;        val rootLayout = findViewById&lt;LinearLayout&gt;(R.id.root_layout)&#10;        rootLayout.addView(gpsStatusText)&#10;        rootLayout.addView(gpsLatLngText)&#10;&#10;        checkAndRequestPermissions()&#10;&#10;        // Wi-Fi送信設定UI&#10;        val ipEditText = findViewById&lt;EditText&gt;(R.id.ip_edittext)&#10;        val portEditText = findViewById&lt;EditText&gt;(R.id.port_edittext)&#10;        val timeoutEditText = findViewById&lt;EditText&gt;(R.id.timeout_edittext)&#10;        val sendTypeSpinner = findViewById&lt;Spinner&gt;(R.id.send_type_spinner)&#10;        val sendTypeAdapter = android.widget.ArrayAdapter(&#10;            this,&#10;            android.R.layout.simple_spinner_item,&#10;            listOf(&quot;http&quot;, &quot;https&quot;, &quot;tcp&quot;, &quot;udp&quot;)&#10;        )&#10;        sendTypeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)&#10;        sendTypeSpinner.adapter = sendTypeAdapter&#10;        sendTypeSpinner.setSelection(0)&#10;&#10;        // 設定値の読み込み（保存値があればそちらを優先）&#10;        val prefs = getSharedPreferences(prefsName, Context.MODE_PRIVATE)&#10;        // config.jsonの値を初回のみSharedPreferencesへ保存&#10;        if (!prefs.contains(keyIp) || !prefs.contains(keyPort) || !prefs.contains(keyTimeout) || !prefs.contains(keySendType)) {&#10;            val config = readConfigJson()&#10;            if (config != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;Config loaded: $config&quot;)&#10;                prefs.edit(true) {&#10;                    putString(keyIp, config.optString(&quot;ip&quot;, AppConstants.DEFAULT_IP))&#10;                    putInt(keyPort, config.optInt(&quot;port&quot;, AppConstants.DEFAULT_PORT))&#10;                    putLong(keyTimeout, config.optLong(&quot;timeout&quot;, AppConstants.DEFAULT_TIMEOUT))&#10;                    putString(keySendType, config.optString(&quot;sendType&quot;, AppConstants.DEFAULT_SEND_TYPE))&#10;                }&#10;            }&#10;        }&#10;        // SharedPreferencesから値を取得してUIに反映&#10;        ipEditText.setText(prefs.getString(keyIp, AppConstants.DEFAULT_IP))&#10;        portEditText.setText(prefs.getInt(keyPort, AppConstants.DEFAULT_PORT).toString())&#10;        timeoutEditText.setText(prefs.getLong(keyTimeout, AppConstants.DEFAULT_TIMEOUT).toString())&#10;        val prefsSendType = prefs.getString(keySendType, AppConstants.DEFAULT_SEND_TYPE)&#10;        sendTypeSpinner.setSelection(listOf(&quot;http&quot;, &quot;https&quot;, &quot;tcp&quot;, &quot;udp&quot;).indexOf(prefsSendType))&#10;&#10;        val startButton = findViewById&lt;Button&gt;(R.id.start_button)&#10;        val stopButton = findViewById&lt;Button&gt;(R.id.stop_button)&#10;        startButton.isEnabled = true&#10;        stopButton.isEnabled = false&#10;&#10;        // 設定ファイルからスライダーの値を取得&#10;        val minInterval = prefs.getInt(&quot;minInterval&quot;, AppConstants.DEFAULT_MIN_INTERVAL)&#10;        val maxInterval = prefs.getInt(&quot;maxInterval&quot;, AppConstants.DEFAULT_MAX_INTERVAL)&#10;        val defaultInterval = prefs.getInt(&quot;defaultInterval&quot;, AppConstants.DEFAULT_INTERVAL)&#10;        val intervalSeekBar = findViewById&lt;SeekBar&gt;(R.id.interval_seekbar)&#10;        intervalSeekBar.min = minInterval&#10;        intervalSeekBar.max = maxInterval&#10;        intervalSeekBar.progress = defaultInterval&#10;&#10;        val intervalValueView = findViewById&lt;TextView&gt;(R.id.interval_value)&#10;        intervalValueView.text = getString(R.string.send_interval, defaultInterval)&#10;&#10;        intervalSeekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {&#10;            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {&#10;                intervalValueView.text = getString(R.string.send_interval, progress)&#10;            }&#10;            override fun onStartTrackingTouch(seekBar: SeekBar?) {}&#10;            override fun onStopTrackingTouch(seekBar: SeekBar?) {}&#10;        })&#10;&#10;        startButton.setOnClickListener {&#10;            val ip = ipEditText.text.toString().ifEmpty { AppConstants.DEFAULT_IP }&#10;            val port = portEditText.text.toString().toIntOrNull() ?: AppConstants.DEFAULT_PORT&#10;            val timeout = timeoutEditText.text.toString().toLongOrNull() ?: AppConstants.DEFAULT_TIMEOUT&#10;            val sendType = sendTypeSpinner.selectedItem.toString()&#10;            var scheme = AppConstants.DEFAULT_SCHEME&#10;            var type = sendType&#10;            val interval = intervalSeekBar.progress.toLong()&#10;            if (sendType == &quot;http&quot; || sendType == &quot;https&quot;) {&#10;                scheme = sendType&#10;                type = &quot;http&quot;&#10;            }&#10;            val intent = Intent(this, GpsService::class.java)&#10;            intent.putExtra(&quot;serverAddress&quot;, ip)&#10;            intent.putExtra(&quot;serverPort&quot;, port)&#10;            intent.putExtra(&quot;sendType&quot;, type)&#10;            intent.putExtra(&quot;intervalMillis&quot;, interval * 1000)&#10;            intent.putExtra(&quot;timeoutMillis&quot;, timeout)&#10;            intent.putExtra(&quot;scheme&quot;, scheme)&#10;            // 設定値の保存（即時反映）&#10;            prefs.edit(true) {&#10;                putString(keyIp, ip)&#10;                putInt(keyPort, port)&#10;                putLong(keyTimeout, timeout)&#10;                putString(keySendType, sendType)&#10;            }&#10;            startForegroundService(intent)&#10;            Toast.makeText(this, &quot;GPS送信サービス開始&quot;, Toast.LENGTH_SHORT).show()&#10;            isSending = true&#10;            setSendingStatus(true)&#10;            startButton.isEnabled = false&#10;            stopButton.isEnabled = true&#10;        }&#10;        stopButton.setOnClickListener {&#10;            stopService(Intent(this, GpsService::class.java))&#10;            Toast.makeText(this, &quot;GPS送信サービス停止&quot;, Toast.LENGTH_SHORT).show()&#10;            isSending = false&#10;            setSendingStatus(false)&#10;            startButton.isEnabled = true&#10;            stopButton.isEnabled = false&#10;        }&#10;&#10;        errorReceiver = object : android.content.BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                if (intent?.action == &quot;com.entangle.gpsOutput.ERROR&quot;) {&#10;                    val errorMsg = intent.getStringExtra(&quot;error_message&quot;) ?: getString(R.string.send_error)&#10;                    setSendingStatus(false)&#10;                    findViewById&lt;Button&gt;(R.id.start_button).isEnabled = true&#10;                    Toast.makeText(this@MainActivity, getString(R.string.send_error_message, errorMsg), Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;        val filter = android.content.IntentFilter(&quot;com.entangle.gpsOutput.ERROR&quot;)&#10;        registerReceiver(errorReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;&#10;        // 位置情報受信用BroadcastReceiverの登録&#10;        locationReceiver = object : android.content.BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                if (intent?.action == &quot;com.entangle.gpsOutput.LOCATION&quot;) {&#10;                    val lat = intent.getDoubleExtra(&quot;latitude&quot;, 0.0)&#10;                    val lng = intent.getDoubleExtra(&quot;longitude&quot;, 0.0)&#10;                    gpsStatusText.text = getString(R.string.gps_acquired)&#10;                    gpsLatLngText.text = getString(R.string.lat_lng, lat, lng)&#10;                    currentLocation = Location(&quot;service&quot;).apply {&#10;                        latitude = lat&#10;                        longitude = lng&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        val locFilter = android.content.IntentFilter(&quot;com.entangle.gpsOutput.LOCATION&quot;)&#10;        registerReceiver(locationReceiver, locFilter, Context.RECEIVER_NOT_EXPORTED)&#10;&#10;        // テキストボックス変更時に即保存&#10;        ipEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val ip = ipEditText.text.toString().ifEmpty { AppConstants.DEFAULT_IP }&#10;                prefs.edit(true) { putString(keyIp, ip) }&#10;            }&#10;        }&#10;        portEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val port = portEditText.text.toString().toIntOrNull() ?: AppConstants.DEFAULT_PORT&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;Port changed: $port&quot;)&#10;                prefs.edit(true) { putInt(keyPort, port) }&#10;            }&#10;        }&#10;        timeoutEditText.setOnFocusChangeListener { _, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                val timeout = timeoutEditText.text.toString().toLongOrNull() ?: AppConstants.DEFAULT_TIMEOUT&#10;                prefs.edit(true) { putLong(keyTimeout, timeout) }&#10;            }&#10;        }&#10;        sendTypeSpinner.setOnItemSelectedListener(object : android.widget.AdapterView.OnItemSelectedListener {&#10;            override fun onItemSelected(parent: android.widget.AdapterView&lt;*&gt;, view: android.view.View?, position: Int, id: Long) {&#10;                val sendType = parent.getItemAtPosition(position).toString()&#10;                prefs.edit(true) { putString(keySendType, sendType) }&#10;            }&#10;            override fun onNothingSelected(parent: android.widget.AdapterView&lt;*&gt;) {}&#10;        })&#10;    }&#10;&#10;    // 権限リクエストの結果を受け取る&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;    }&#10;&#10;    private fun checkAndRequestPermissions() {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;checkAndRequestPermissions called&quot;)&#10;        val permissionsToRequest = mutableListOf&lt;String&gt;()&#10;        permissionsToRequest.add(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        permissionsToRequest.add(Manifest.permission.ACCESS_COARSE_LOCATION)&#10;&#10;        val permissionsNotGranted = permissionsToRequest.filter {&#10;            ActivityCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNotGranted.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNotGranted.toTypedArray(), 100)&#10;        }&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu): Boolean {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onCreateOptionsMenu called&quot;)&#10;        menuInflater.inflate(R.menu.menu_main, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;onOptionsItemSelected called&quot;)&#10;        return when (item.itemId) {&#10;            R.id.action_background -&gt; {&#10;                moveTaskToBack(true)&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun setSendingStatus(isSending: Boolean) {&#10;        android.util.Log.d(&quot;MainActivity&quot;, &quot;setSendingStatus called: isSending=$isSending&quot;)&#10;        gpsStatusText.text = if (isSending) &quot;送信中&quot; else &quot;&quot;&#10;        if (isSending &amp;&amp; currentLocation != null) {&#10;            gpsLatLngText.text = getString(R.string.lat_lng, currentLocation!!.latitude, currentLocation!!.longitude)&#10;        } else if (!isSending) {&#10;            gpsLatLngText.text = getString(R.string.lat_lng_not_acquired)&#10;        }&#10;    }&#10;&#10;    private fun readConfigJson(): JSONObject? {&#10;        return try {&#10;            val inputStream: InputStream = assets.open(&quot;config.json&quot;)&#10;            val size = inputStream.available()&#10;            val buffer = ByteArray(size)&#10;            inputStream.read(buffer)&#10;            inputStream.close()&#10;            val json = String(buffer, Charsets.UTF_8)&#10;            JSONObject(json)&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(errorReceiver)&#10;        unregisterReceiver(locationReceiver)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/SppManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/entangle/gpsoutput/SppManager.kt" />
              <option name="originalContent" value="package com.entangle.gpsoutput&#10;&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothSocket&#10;import android.content.Context&#10;import java.io.IOException&#10;import java.io.InputStream&#10;import java.io.OutputStream&#10;import java.util.UUID&#10;&#10;class SppManager(private val context: Context) {&#10;    private var socket: BluetoothSocket? = null&#10;    private var outputStream: OutputStream? = null&#10;    private var inputStream: InputStream? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        // SPPの標準UUID&#10;        val SPP_UUID: UUID = UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;)&#10;    }&#10;&#10;    fun connect(device: BluetoothDevice, onConnected: () -&gt; Unit, onDisconnected: () -&gt; Unit) {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;connect() called. device: ${device.address}&quot;)&#10;        val permission = android.Manifest.permission.BLUETOOTH_CONNECT&#10;        val hasPermission = androidx.core.content.ContextCompat.checkSelfPermission(context, permission) == android.content.pm.PackageManager.PERMISSION_GRANTED&#10;        if (!hasPermission) {&#10;            onDisconnected()&#10;            return&#10;        }&#10;        try {&#10;            // RFCOMMチャンネル1で直接接続（UUID方式ではなくリフレクション利用）&#10;            val method = device.javaClass.getMethod(&quot;createRfcommSocket&quot;, Int::class.javaPrimitiveType)&#10;            socket = method.invoke(device, 1) as BluetoothSocket&#10;            // SPP UUID方式で接続&#10;            //socket = device.createRfcommSocketToServiceRecord(SPP_UUID)&#10;            socket?.connect()&#10;            outputStream = socket?.outputStream&#10;            inputStream = socket?.inputStream&#10;            isConnected = true&#10;            onConnected()&#10;        } catch (e: SecurityException) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() SecurityException: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        } catch (e: IOException) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() IOException: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() Exception: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        }&#10;    }&#10;&#10;    fun send(data: ByteArray) {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;send() called. data size: ${data.size}&quot;)&#10;        if (isConnected) {&#10;            Thread {&#10;                try {&#10;                    val dataWithNewline = data + &quot;\n&quot;.toByteArray()&#10;                    outputStream?.write(dataWithNewline)&#10;                    outputStream?.flush()&#10;                } catch (e: IOException) {&#10;                    val dataStr = data.joinToString(&quot;,&quot;) { it.toUByte().toString(16).padStart(2, '0') }&#10;                    val msg = &quot;SPP送信エラー: ${e.message}\n送信データ: ${dataStr}&quot;&#10;                    android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                        android.widget.Toast.makeText(context, msg, android.widget.Toast.LENGTH_LONG).show()&#10;                    }&#10;                    // 送信失敗時のみ切断&#10;                    disconnect()&#10;                }&#10;            }.start()&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;disconnect() called.&quot;)&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;        } catch (e: IOException) {&#10;            // ignore&#10;        }&#10;        isConnected = false&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.entangle.gpsoutput&#10;&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothSocket&#10;import android.content.Context&#10;import java.io.IOException&#10;import java.io.InputStream&#10;import java.io.OutputStream&#10;import java.util.UUID&#10;&#10;class SppManager(private val context: Context) {&#10;    private var socket: BluetoothSocket? = null&#10;    private var outputStream: OutputStream? = null&#10;    private var inputStream: InputStream? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        // SPPの標準UUID&#10;        val SPP_UUID: UUID = UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;)&#10;    }&#10;&#10;    fun connect(device: BluetoothDevice, onConnected: () -&gt; Unit, onDisconnected: () -&gt; Unit) {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;connect() called. device: ${device.address}&quot;)&#10;        val permission = android.Manifest.permission.BLUETOOTH_CONNECT&#10;        val hasPermission = androidx.core.content.ContextCompat.checkSelfPermission(context, permission) == android.content.pm.PackageManager.PERMISSION_GRANTED&#10;        if (!hasPermission) {&#10;            onDisconnected()&#10;            return&#10;        }&#10;        try {&#10;            // BluetoothAdapter.cancelDiscovery()を追加&#10;            val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as android.bluetooth.BluetoothManager&#10;            val bluetoothAdapter = bluetoothManager.adapter&#10;            bluetoothAdapter.cancelDiscovery()&#10;            // RFCOMMチャンネル1で直接接続（リフレクション方式）&#10;            val method = device.javaClass.getMethod(&quot;createRfcommSocket&quot;, Int::class.javaPrimitiveType)&#10;            socket = method.invoke(device, 1) as BluetoothSocket&#10;            socket?.connect()&#10;            outputStream = socket?.outputStream&#10;            inputStream = socket?.inputStream&#10;            isConnected = true&#10;            onConnected()&#10;        } catch (e: SecurityException) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() SecurityException: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        } catch (e: IOException) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() IOException: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;SppManager&quot;, &quot;connect() Exception: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;SppManager&quot;, android.util.Log.getStackTraceString(e))&#10;            disconnect()&#10;            onDisconnected()&#10;        }&#10;    }&#10;&#10;    fun send(data: ByteArray) {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;send() called. data size: ${data.size}&quot;)&#10;        if (isConnected) {&#10;            Thread {&#10;                try {&#10;                    val dataWithNewline = data + &quot;\n&quot;.toByteArray()&#10;                    outputStream?.write(dataWithNewline)&#10;                    outputStream?.flush()&#10;                } catch (e: IOException) {&#10;                    val dataStr = data.joinToString(&quot;,&quot;) { it.toUByte().toString(16).padStart(2, '0') }&#10;                    val msg = &quot;SPP送信エラー: ${e.message}\n送信データ: ${dataStr}&quot;&#10;                    android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                        android.widget.Toast.makeText(context, msg, android.widget.Toast.LENGTH_LONG).show()&#10;                    }&#10;                    // 送信失敗時のみ切断&#10;                    disconnect()&#10;                }&#10;            }.start()&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        android.util.Log.d(&quot;SppManager&quot;, &quot;disconnect() called.&quot;)&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;        } catch (e: IOException) {&#10;            // ignore&#10;        }&#10;        isConnected = false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/menu/menu_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/menu/menu_main.xml" />
              <option name="originalContent" value="&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    tools:context=&quot;com.entangle.gpsoutput.MainActivity&quot;&gt;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_reload&quot;&#10;        android:title=&quot;更新&quot;&#10;        android:icon=&quot;@android:drawable/ic_menu_rotate&quot;&#10;        app:showAsAction=&quot;ifRoom&quot; /&gt;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_background&quot;&#10;        android:title=&quot;@string/action_background&quot;&#10;        android:icon=&quot;@android:drawable/ic_menu_revert&quot;&#10;        app:showAsAction=&quot;ifRoom&quot; /&gt;&#10;&lt;/menu&gt;" />
              <option name="updatedContent" value="&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    tools:context=&quot;com.entangle.gpsoutput.MainActivity&quot;&gt;&#10;    &lt;item&#10;        android:id=&quot;@+id/action_background&quot;&#10;        android:title=&quot;@string/action_background&quot;&#10;        android:icon=&quot;@android:drawable/ic_menu_revert&quot;&#10;        app:showAsAction=&quot;ifRoom&quot; /&gt;&#10;&lt;/menu&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/navigation/nav_graph.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/navigation/nav_graph.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/nav_graph&quot;&#10;    app:startDestination=&quot;@id/FirstFragment&quot;&gt;&#10;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/FirstFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.FirstFragment&quot;&#10;        android:label=&quot;@string/first_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_first&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_FirstFragment_to_SecondFragment&quot;&#10;            app:destination=&quot;@id/SecondFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/SecondFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.SecondFragment&quot;&#10;        android:label=&quot;@string/second_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_second&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_SecondFragment_to_FirstFragment&quot;&#10;            app:destination=&quot;@id/FirstFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    app:startDestination=&quot;@id/FirstFragment&quot;&gt;&#10;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/FirstFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.FirstFragment&quot;&#10;        android:label=&quot;@string/first_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_first&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_FirstFragment_to_SecondFragment&quot;&#10;            app:destination=&quot;@id/SecondFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/SecondFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.SecondFragment&quot;&#10;        android:label=&quot;@string/second_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_second&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_SecondFragment_to_FirstFragment&quot;&#10;            app:destination=&quot;@id/FirstFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    app:startDestination=&quot;@id/FirstFragment&quot;&gt;&#10;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/FirstFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.FirstFragment&quot;&#10;        android:label=&quot;@string/first_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_first&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_FirstFragment_to_SecondFragment&quot;&#10;            app:destination=&quot;@id/SecondFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/SecondFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.SecondFragment&quot;&#10;        android:label=&quot;@string/second_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_second&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_SecondFragment_to_FirstFragment&quot;&#10;            app:destination=&quot;@id/FirstFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    app:startDestination=&quot;@id/FirstFragment&quot;&gt;&#10;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/FirstFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.FirstFragment&quot;&#10;        android:label=&quot;@string/first_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_first&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_FirstFragment_to_SecondFragment&quot;&#10;            app:destination=&quot;@id/SecondFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/SecondFragment&quot;&#10;        android:name=&quot;com.entangle.gpsoutput.SecondFragment&quot;&#10;        android:label=&quot;@string/second_fragment_label&quot;&#10;        tools:layout=&quot;@layout/fragment_second&quot;&gt;&#10;&#10;        &lt;action&#10;            android:id=&quot;@+id/action_SecondFragment_to_FirstFragment&quot;&#10;            app:destination=&quot;@id/FirstFragment&quot; /&gt;&#10;    &lt;/fragment&gt;&#10;&lt;/navigation&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/nav_graph&quot;&gt;&#10;&lt;/navigation&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>